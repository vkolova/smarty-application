import * as WebSocket from "ws";
import { ClientOptions } from "./client-options";
export declare const corePlugins: (((reactotron: Reactotron) => {
    features: {
        log: (...args: any[]) => void;
        logImportant: (...args: any[]) => void;
        debug: (message: any, important?: boolean) => void;
        warn: (message: any) => void;
        error: (message: any, stack: any) => void;
    };
}) | ((reactotron: Reactotron) => {
    features: {
        image: ({ uri, preview, filename, width, height, caption }: {
            uri: any;
            preview: any;
            filename: any;
            width: any;
            height: any;
            caption: any;
        }) => void;
    };
}) | ((reactotron: Reactotron) => {
    features: {
        benchmark: (title: any) => {
            step: (stepTitle: any) => void;
            stop: (stopTitle: any) => void;
            last: (stopTitle: any) => void;
        };
    };
}) | ((reactotron: Reactotron) => {
    features: {
        stateActionComplete: (name: any, action: any, important?: boolean) => void;
        stateValuesResponse: (path: any, value: any, valid?: boolean) => void;
        stateKeysResponse: (path: any, keys: any, valid?: boolean) => void;
        stateValuesChange: (changes: any) => void;
        stateBackupResponse: (state: any) => void;
    };
}) | ((reactotron: Reactotron) => {
    features: {
        apiResponse: (request: any, response: any, duration: any) => void;
    };
}) | ((reactotron: Reactotron) => {
    features: {
        clear: () => void;
    };
}))[];
export interface CustomCommand {
    id: number;
    command: string;
    handler: () => void;
}
export interface Reactotron {
    startTimer: () => () => number;
    configure: (options?: ClientOptions) => Reactotron;
    close: () => void;
    connect: () => Reactotron;
    send: (type: any, payload?: any, important?: boolean) => void;
    display: (config?: any) => void;
    reportError: (this: any, error: any) => void;
    use: (pluginCreator?: (client: Reactotron) => any) => Reactotron;
    onCustomCommand: (command: string, handler: () => void) => () => void;
    apiResponse?: (request: any, response: any, duration: any) => void;
    benchmark?: (title: string) => {
        step: (stepName: string) => void;
        stop: (stopTitle: string) => void;
        last: (stopTitle: string) => void;
    };
    clear?: () => void;
    image?: (options: {
        uri: any;
        preview: any;
        filename: any;
        width: any;
        height: any;
        caption: any;
    }) => void;
    log?: (...args: any[]) => void;
    logImportant?: (...args: any[]) => void;
    debug?: (message: any, important?: boolean) => void;
    warn?: (message: any) => void;
    error?: (message: any, stack: any) => void;
    stateActionComplete?: (name: any, action: any, important?: boolean) => void;
    stateValuesResponse?: (path: any, value: any, valid?: boolean) => void;
    stateKeysResponse?: (path: any, keys: any, valid?: boolean) => void;
    stateValuesChange?: (changes: any) => void;
    stateBackupResponse?: (state: any) => void;
}
export declare class ReactotronImpl implements Reactotron {
    options: ClientOptions;
    /**
     * Are we connected to a server?
     */
    connected: boolean;
    /**
     * The socket we're using.
     */
    socket: WebSocket;
    /**
     * Available plugins.
     */
    plugins: any[];
    /**
     * Messages that need to be sent.
     */
    sendQueue: any[];
    /**
     * Are we ready to start communicating?
     */
    isReady: boolean;
    /**
     * The last time we sent a message.
     */
    lastMessageDate: Date;
    /**
     * The registered custom commands
     */
    customCommands: CustomCommand[];
    /**
     * The current ID for custom commands
     */
    customCommandLatestId: number;
    /**
     * Starts a timer and returns a function you can call to stop it and return the elapsed time.
     */
    startTimer: () => () => number;
    /**
     * Set the configuration options.
     */
    configure(options?: ClientOptions): Reactotron;
    close(): void;
    /**
     * Connect to the Reactotron server.
     */
    connect(): Reactotron;
    /**
     * Sends a command to the server
     */
    send: (type: any, payload?: {}, important?: boolean) => void;
    /**
     * Sends a custom command to the server to displays nicely.
     */
    display(config?: any): void;
    /**
     * Client libraries can hijack this to report errors.
     */
    reportError(this: any, error: any): void;
    /**
     * Adds a plugin to the system
     */
    use(pluginCreator?: (client: Reactotron) => any): Reactotron;
    onCustomCommand(command: string, handler: () => void): () => void;
}
export declare function createClient(options?: ClientOptions): ReactotronImpl;
